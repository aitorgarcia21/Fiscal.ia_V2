interface ActionItem {
  id: string;
  title: string;
  description: string;
  category: 'CLIENT_CONTACT' | 'DOCUMENT_PREP' | 'CALCULATION' | 'FOLLOW_UP' | 'COMPLIANCE' | 'EXPERTISE' | 'ADMIN';
  priority: 'CRITIQUE' | 'HAUTE' | 'MOYENNE' | 'FAIBLE';
  urgency: 'IMMEDIATE' | 'AUJOURD_HUI' | 'CETTE_SEMAINE' | 'CE_MOIS' | 'PLUS_TARD';
  
  source: 'MEETING' | 'CLIENT_EMAIL' | 'MARKET_UPDATE' | 'COMPLIANCE' | 'SYSTEM' | 'MANUAL';
  sourceId?: string;
  createdAt: Date;
  dueDate?: Date;
  estimatedDuration: number;
  
  assignedTo: 'ADVISOR' | 'ASSISTANT' | 'EXPERT' | 'CLIENT';
  owner: string;
  
  clientId?: string;
  relatedDocuments: string[];
  dependencies: string[];
  tags: string[];
  
  status: 'TODO' | 'IN_PROGRESS' | 'WAITING' | 'DONE' | 'CANCELLED';
  progress: number;
  completedAt?: Date;
  notes: string[];
  
  autoGenerated: boolean;
  recurring?: { frequency: 'DAILY' | 'WEEKLY' | 'MONTHLY' | 'YEARLY'; nextOccurrence: Date; };
  
  businessImpact: 'CHIFFRE_AFFAIRES' | 'SATISFACTION_CLIENT' | 'COMPLIANCE' | 'EFFICACITE' | 'NONE';
  estimatedValue?: number;
}

interface SmartSuggestion {
  type: 'OPTIMIZATION' | 'AUTOMATION' | 'DELEGATION' | 'SCHEDULING' | 'BUNDLING';
  title: string;
  description: string;
  impact: 'TEMPS_GAGNE' | 'QUALITE_AMELIOREE' | 'RISQUE_REDUIT' | 'CLIENT_SATISFAIT';
  estimatedGain: string;
  actions: string[];
}

interface ActionDashboard {
  summary: {
    total: number;
    byPriority: Record<ActionItem['priority'], number>;
    byUrgency: Record<ActionItem['urgency'], number>;
    byStatus: Record<ActionItem['status'], number>;
    overdueCount: number;
    todayCount: number;
  };
  
  suggestions: SmartSuggestion[];
  
  optimizedSchedule: Array<{
    timeSlot: string;
    actions: ActionItem[];
    reasoning: string;
  }>;
  
  alerts: Array<{
    type: 'DEADLINE_APPROACHING' | 'OVERDUE' | 'BOTTLENECK' | 'OPPORTUNITY';
    message: string;
    actionIds: string[];
    severity: 'INFO' | 'WARNING' | 'CRITICAL';
  }>;
}

class ActionExtractor {
  private actions: Map<string, ActionItem> = new Map();
  private francisApiUrl = process.env.REACT_APP_FRANCIS_API_URL || 'http://localhost:8000';
  
  private actionPatterns = [
    {
      pattern: /(?:envoyer|transmettre|faire parvenir)\s+(.+?)\s+(?:√†|au client)/gi,
      category: 'DOCUMENT_PREP' as const,
      priority: 'MOYENNE' as const,
      template: 'Envoyer {document} au client'
    },
    {
      pattern: /(?:calculer|estimer|simuler)\s+(.+)/gi,
      category: 'CALCULATION' as const,
      priority: 'HAUTE' as const,
      template: 'Calculer {calcul}'
    },
    {
      pattern: /(?:rappeler|relancer|contacter)\s+(.+?)\s+(?:pour|concernant)/gi,
      category: 'CLIENT_CONTACT' as const,
      priority: 'HAUTE' as const,
      template: 'Rappeler client pour {sujet}'
    }
  ];

  async extractActionsFromMeeting(meetingTranscription: string, meetingContext: any): Promise<ActionItem[]> {
    console.log('üéØ EXTRACTION ACTIONS MEETING:', meetingContext.clientId);
    
    try {
      const francisActions = await this.extractWithFrancis(meetingTranscription, meetingContext);
      const patternActions = this.extractWithPatterns(meetingTranscription, meetingContext);
      const contextualActions = this.generateContextualActions(meetingContext);
      
      const allActions = [...francisActions, ...patternActions, ...contextualActions];
      const uniqueActions = this.deduplicateActions(allActions);
      const enrichedActions = await this.enrichActions(uniqueActions, meetingContext);
      
      enrichedActions.forEach(action => {
        this.actions.set(action.id, action);
      });
      
      await this.saveActions(enrichedActions);
      
      console.log('‚úÖ ACTIONS EXTRAITES:', enrichedActions.length, 'actions cr√©√©es');
      return enrichedActions;
      
    } catch (error) {
      console.error('‚ùå Erreur extraction actions:', error);
      throw new Error(`√âchec extraction: ${error instanceof Error ? error.message : 'Erreur inconnue'}`);
    }
  }

  private async extractWithFrancis(transcription: string, context: any): Promise<ActionItem[]> {
    try {
      const prompt = `
Tu es Francis, assistant IA expert en conseil patrimonial. 
Analyse cette transcription de rendez-vous et extrais TOUTES les actions √† r√©aliser.

TRANSCRIPTION:
${transcription}

CONTEXTE:
- Client: ${context.clientId}
- Type de meeting: ${context.type}
- Objectifs: ${context.objectives?.join(', ')}

EXTRACTION DEMAND√âE:
Identifie et liste TOUTES les actions mentionn√©es ou implicites:
1. Actions explicitement demand√©es par le client
2. Actions promises par le conseiller 
3. Documents √† envoyer
4. Calculs √† effectuer
5. V√©rifications de compliance
6. Suivis n√©cessaires

FORMAT DE R√âPONSE:
Pour chaque action, fournis:
- Titre clair et actionnable
- Description d√©taill√©e
- Cat√©gorie (CLIENT_CONTACT, DOCUMENT_PREP, CALCULATION, etc.)
- Priorit√© (CRITIQUE, HAUTE, MOYENNE, FAIBLE)
- Urgence (IMMEDIATE, AUJOURD_HUI, CETTE_SEMAINE, etc.)
- Dur√©e estim√©e en minutes
- Personne responsable

Sois exhaustif et pr√©cis pour un suivi client parfait.
`;

      const response = await fetch(`${this.francisApiUrl}/extract_actions`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          transcription,
          context,
          prompt,
          extract_all: true
        })
      });

      if (!response.ok) {
        throw new Error(`Francis API error: ${response.statusText}`);
      }

      const francisResult = await response.json();
      return this.convertFrancisActions(francisResult.actions || [], context);
      
    } catch (error) {
      console.warn('Erreur extraction Francis, fallback patterns:', error);
      return [];
    }
  }

  private extractWithPatterns(transcription: string, context: any): ActionItem[] {
    const actions: ActionItem[] = [];
    
    this.actionPatterns.forEach(pattern => {
      const matches = Array.from(transcription.matchAll(pattern.pattern));
      matches.forEach((match, index) => {
        const actionTitle = pattern.template.replace('{document}', match[1])
                                         .replace('{calcul}', match[1])
                                         .replace('{sujet}', match[1]);
        
        actions.push({
          id: `pattern-${Date.now()}-${index}`,
          title: actionTitle,
          description: `Action extraite: ${match[0]}`,
          category: pattern.category,
          priority: pattern.priority,
          urgency: 'CETTE_SEMAINE',
          source: 'MEETING',
          sourceId: context.meetingId,
          createdAt: new Date(),
          estimatedDuration: this.estimateDuration(pattern.category),
          assignedTo: 'ADVISOR',
          owner: context.advisorId || 'francis',
          clientId: context.clientId,
          relatedDocuments: [],
          dependencies: [],
          tags: [pattern.category.toLowerCase()],
          status: 'TODO',
          progress: 0,
          notes: [],
          autoGenerated: true,
          businessImpact: this.determineBusinessImpact(pattern.category)
        });
      });
    });
    
    return actions;
  }

  private generateContextualActions(context: any): ActionItem[] {
    const actions: ActionItem[] = [];
    
    actions.push({
      id: `followup-${Date.now()}`,
      title: 'Suivi post-rendez-vous client',
      description: 'Email de remerciement et r√©capitulatif des points abord√©s',
      category: 'CLIENT_CONTACT',
      priority: 'HAUTE',
      urgency: 'AUJOURD_HUI',
      source: 'SYSTEM',
      createdAt: new Date(),
      dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000),
      estimatedDuration: 15,
      assignedTo: 'ADVISOR',
      owner: context.advisorId || 'francis',
      clientId: context.clientId,
      relatedDocuments: [],
      dependencies: [],
      tags: ['suivi', 'meeting'],
      status: 'TODO',
      progress: 0,
      notes: [],
      autoGenerated: true,
      businessImpact: 'SATISFACTION_CLIENT'
    });
    
    if (context.type === 'PREMIER_CONTACT') {
      actions.push({
        id: `dossier-${Date.now()}`,
        title: 'Cr√©er dossier client complet',
        description: 'Saisie compl√®te profil client et ouverture dossier administratif',
        category: 'ADMIN',
        priority: 'HAUTE',
        urgency: 'CETTE_SEMAINE',
        source: 'SYSTEM',
        createdAt: new Date(),
        estimatedDuration: 45,
        assignedTo: 'ASSISTANT',
        owner: context.advisorId || 'francis',
        clientId: context.clientId,
        relatedDocuments: [],
        dependencies: [],
        tags: ['dossier', 'admin'],
        status: 'TODO',
        progress: 0,
        notes: [],
        autoGenerated: true,
        businessImpact: 'COMPLIANCE'
      });
    }
    
    return actions;
  }

  private deduplicateActions(actions: ActionItem[]): ActionItem[] {
    const uniqueActions: ActionItem[] = [];
    const seen = new Set<string>();
    
    actions.forEach(action => {
      const normalizedTitle = action.title.toLowerCase()
        .replace(/[^a-z0-9\s]/g, '')
        .replace(/\s+/g, ' ')
        .trim();
      
      const dedupeKey = `${action.category}-${normalizedTitle}-${action.clientId}`;
      
      if (!seen.has(dedupeKey)) {
        seen.add(dedupeKey);
        uniqueActions.push(action);
      }
    });
    
    return uniqueActions;
  }

  private async enrichActions(actions: ActionItem[], context: any): Promise<ActionItem[]> {
    return Promise.all(actions.map(async action => {
      if (!action.dueDate) {
        action.dueDate = this.calculateSmartDueDate(action, context);
      }
      
      action.assignedTo = this.determineOptimalAssignee(action, context);
      action.tags = [...action.tags, ...this.generateSmartTags(action, context)];
      action.dependencies = this.identifyDependencies(action, actions);
      
      if (!action.estimatedValue) {
        action.estimatedValue = this.estimateBusinessValue(action, context);
      }
      
      return action;
    }));
  }

  private convertFrancisActions(francisActions: any[], context: any): ActionItem[] {
    return francisActions.map((fa, index) => ({
      id: `francis-${Date.now()}-${index}`,
      title: fa.title || fa.action || 'Action Francis',
      description: fa.description || fa.details || '',
      category: this.mapFrancisCategory(fa.category) || 'FOLLOW_UP',
      priority: this.mapFrancisPriority(fa.priority) || 'MOYENNE',
      urgency: this.mapFrancisUrgency(fa.urgency) || 'CETTE_SEMAINE',
      source: 'MEETING',
      sourceId: context.meetingId,
      createdAt: new Date(),
      estimatedDuration: fa.duration || this.estimateDuration(fa.category),
      assignedTo: this.mapFrancisAssignee(fa.assignee) || 'ADVISOR',
      owner: context.advisorId || 'francis',
      clientId: context.clientId,
      relatedDocuments: fa.documents || [],
      dependencies: [],
      tags: fa.tags || [],
      status: 'TODO',
      progress: 0,
      notes: [],
      autoGenerated: true,
      businessImpact: this.determineBusinessImpact(fa.category) || 'NONE'
    }));
  }

  async generateSmartDashboard(advisorId: string): Promise<ActionDashboard> {
    console.log('üìä G√âN√âRATION DASHBOARD TO-DO:', advisorId);
    
    try {
      const advisorActions = Array.from(this.actions.values())
        .filter(action => action.owner === advisorId);
      
      const summary = this.calculateSummary(advisorActions);
      const suggestions = await this.generateSmartSuggestions(advisorActions);
      const optimizedSchedule = this.generateOptimizedSchedule(advisorActions);
      const alerts = this.generateAlerts(advisorActions);
      
      return { summary, suggestions, optimizedSchedule, alerts };
      
    } catch (error) {
      console.error('Erreur g√©n√©ration dashboard:', error);
      throw error;
    }
  }

  private calculateSummary(actions: ActionItem[]) {
    const now = new Date();
    
    return {
      total: actions.length,
      byPriority: {
        'CRITIQUE': actions.filter(a => a.priority === 'CRITIQUE').length,
        'HAUTE': actions.filter(a => a.priority === 'HAUTE').length,
        'MOYENNE': actions.filter(a => a.priority === 'MOYENNE').length,
        'FAIBLE': actions.filter(a => a.priority === 'FAIBLE').length
      },
      byUrgency: {
        'IMMEDIATE': actions.filter(a => a.urgency === 'IMMEDIATE').length,
        'AUJOURD_HUI': actions.filter(a => a.urgency === 'AUJOURD_HUI').length,
        'CETTE_SEMAINE': actions.filter(a => a.urgency === 'CETTE_SEMAINE').length,
        'CE_MOIS': actions.filter(a => a.urgency === 'CE_MOIS').length,
        'PLUS_TARD': actions.filter(a => a.urgency === 'PLUS_TARD').length
      },
      byStatus: {
        'TODO': actions.filter(a => a.status === 'TODO').length,
        'IN_PROGRESS': actions.filter(a => a.status === 'IN_PROGRESS').length,
        'WAITING': actions.filter(a => a.status === 'WAITING').length,
        'DONE': actions.filter(a => a.status === 'DONE').length,
        'CANCELLED': actions.filter(a => a.status === 'CANCELLED').length
      },
      overdueCount: actions.filter(a => a.dueDate && a.dueDate < now && a.status !== 'DONE').length,
      todayCount: actions.filter(a => a.urgency === 'AUJOURD_HUI' || a.urgency === 'IMMEDIATE').length
    };
  }

  private async generateSmartSuggestions(actions: ActionItem[]): Promise<SmartSuggestion[]> {
    const suggestions: SmartSuggestion[] = [];
    
    const groupableActions = this.findGroupableActions(actions);
    if (groupableActions.length > 1) {
      suggestions.push({
        type: 'BUNDLING',
        title: 'Regrouper les actions similaires',
        description: `${groupableActions.length} actions peuvent √™tre trait√©es ensemble`,
        impact: 'TEMPS_GAGNE',
        estimatedGain: '30% de temps gagn√©',
        actions: groupableActions.map(a => a.id)
      });
    }
    
    const automatizableActions = actions.filter(a => a.autoGenerated && a.category === 'DOCUMENT_PREP');
    if (automatizableActions.length >= 3) {
      suggestions.push({
        type: 'AUTOMATION',
        title: 'Automatiser l\'envoi de documents',
        description: 'Cr√©er des templates automatiques pour les documents r√©currents',
        impact: 'TEMPS_GAGNE',
        estimatedGain: '2h par semaine',
        actions: automatizableActions.map(a => a.id)
      });
    }
    
    const delegatableActions = actions.filter(a => a.category === 'ADMIN' && a.assignedTo === 'ADVISOR');
    if (delegatableActions.length > 0) {
      suggestions.push({
        type: 'DELEGATION',
        title: 'D√©l√©guer les t√¢ches administratives',
        description: 'R√©assigner les t√¢ches admin √† l\'assistant',
        impact: 'TEMPS_GAGNE',
        estimatedGain: '1h par jour',
        actions: delegatableActions.map(a => a.id)
      });
    }
    
    return suggestions;
  }

  private generateOptimizedSchedule(actions: ActionItem[]) {
    const schedule = [];
    const availableSlots = ['09:00-10:30', '10:30-12:00', '14:00-15:30', '15:30-17:00'];
    
    const sortedActions = actions
      .filter(a => a.status === 'TODO')
      .sort((a, b) => {
        const priorityA = this.getPriorityWeight(a.priority);
        const priorityB = this.getPriorityWeight(b.priority);
        const urgencyA = this.getUrgencyWeight(a.urgency);
        const urgencyB = this.getUrgencyWeight(b.urgency);
        
        return (priorityB + urgencyB) - (priorityA + urgencyA);
      });
    
    let actionIndex = 0;
    availableSlots.forEach(slot => {
      const slotActions = [];
      const slotDuration = 90;
      let usedTime = 0;
      
      while (actionIndex < sortedActions.length && usedTime < slotDuration) {
        const action = sortedActions[actionIndex];
        if (usedTime + action.estimatedDuration <= slotDuration) {
          slotActions.push(action);
          usedTime += action.estimatedDuration;
          actionIndex++;
        } else {
          break;
        }
      }
      
      if (slotActions.length > 0) {
        schedule.push({
          timeSlot: slot,
          actions: slotActions,
          reasoning: `Optimis√© pour ${slotActions.length} actions (${usedTime}min)`
        });
      }
    });
    
    return schedule;
  }

  private generateAlerts(actions: ActionItem[]) {
    const alerts = [];
    const now = new Date();
    
    const overdueActions = actions.filter(a => 
      a.dueDate && a.dueDate < now && a.status !== 'DONE'
    );
    
    if (overdueActions.length > 0) {
      alerts.push({
        type: 'OVERDUE' as const,
        message: `${overdueActions.length} action(s) en retard`,
        actionIds: overdueActions.map(a => a.id),
        severity: 'CRITICAL' as const
      });
    }
    
    const criticalActions = actions.filter(a => 
      a.priority === 'CRITIQUE' && a.status === 'TODO'
    );
    
    if (criticalActions.length >= 3) {
      alerts.push({
        type: 'BOTTLENECK' as const,
        message: 'Concentration d\'actions critiques d√©tect√©e',
        actionIds: criticalActions.map(a => a.id),
        severity: 'WARNING' as const
      });
    }
    
    return alerts;
  }

  // Utilitaires
  private estimateDuration(category: ActionItem['category']): number {
    const durations = {
      'CLIENT_CONTACT': 20,
      'DOCUMENT_PREP': 30,
      'CALCULATION': 45,
      'FOLLOW_UP': 15,
      'COMPLIANCE': 30,
      'EXPERTISE': 60,
      'ADMIN': 25
    };
    
    return durations[category] || 30;
  }

  private determineBusinessImpact(category: ActionItem['category']): ActionItem['businessImpact'] {
    const impacts = {
      'CLIENT_CONTACT': 'SATISFACTION_CLIENT',
      'DOCUMENT_PREP': 'EFFICACITE',
      'CALCULATION': 'CHIFFRE_AFFAIRES',
      'FOLLOW_UP': 'SATISFACTION_CLIENT',
      'COMPLIANCE': 'COMPLIANCE',
      'EXPERTISE': 'CHIFFRE_AFFAIRES',
      'ADMIN': 'EFFICACITE'
    };
    
    return impacts[category] as ActionItem['businessImpact'] || 'NONE';
  }

  private calculateSmartDueDate(action: ActionItem, context: any): Date {
    const now = new Date();
    const urgencyDelays = {
      'IMMEDIATE': 2 * 60 * 60 * 1000,
      'AUJOURD_HUI': 24 * 60 * 60 * 1000,
      'CETTE_SEMAINE': 7 * 24 * 60 * 60 * 1000,
      'CE_MOIS': 30 * 24 * 60 * 60 * 1000,
      'PLUS_TARD': 90 * 24 * 60 * 60 * 1000
    };
    
    return new Date(now.getTime() + urgencyDelays[action.urgency]);
  }

  private determineOptimalAssignee(action: ActionItem, context: any): ActionItem['assignedTo'] {
    if (action.category === 'ADMIN') return 'ASSISTANT';
    if (action.category === 'EXPERTISE' && action.estimatedDuration > 60) return 'EXPERT';
    if (action.category === 'CLIENT_CONTACT') return 'ADVISOR';
    
    return action.assignedTo;
  }

  private generateSmartTags(action: ActionItem, context: any): string[] {
    const tags = [];
    
    if (action.clientId) tags.push(`client-${action.clientId}`);
    if (action.priority === 'CRITIQUE') tags.push('urgent');
    if (action.estimatedDuration > 60) tags.push('long');
    if (action.businessImpact === 'CHIFFRE_AFFAIRES') tags.push('revenue');
    
    return tags;
  }

  private identifyDependencies(action: ActionItem, allActions: ActionItem[]): string[] {
    const dependencies = [];
    
    if (action.title.includes('simulation') || action.title.includes('calcul')) {
      const dataCollectionAction = allActions.find(a => 
        a.category === 'DOCUMENT_PREP' && a.clientId === action.clientId
      );
      if (dataCollectionAction) {
        dependencies.push(dataCollectionAction.id);
      }
    }
    
    return dependencies;
  }

  private estimateBusinessValue(action: ActionItem, context: any): number {
    const baseValues = {
      'CHIFFRE_AFFAIRES': 5000,
      'SATISFACTION_CLIENT': 2000,
      'COMPLIANCE': 1000,
      'EFFICACITE': 500,
      'NONE': 0
    };
    
    return baseValues[action.businessImpact];
  }

  private findGroupableActions(actions: ActionItem[]): ActionItem[] {
    return actions.filter(a => a.category === 'CLIENT_CONTACT').slice(0, 3);
  }

  private getPriorityWeight(priority: ActionItem['priority']): number {
    const weights = { 'CRITIQUE': 4, 'HAUTE': 3, 'MOYENNE': 2, 'FAIBLE': 1 };
    return weights[priority];
  }

  private getUrgencyWeight(urgency: ActionItem['urgency']): number {
    const weights = { 'IMMEDIATE': 5, 'AUJOURD_HUI': 4, 'CETTE_SEMAINE': 3, 'CE_MOIS': 2, 'PLUS_TARD': 1 };
    return weights[urgency];
  }

  private mapFrancisCategory(category: any): ActionItem['category'] | undefined {
    const mapping: Record<string, ActionItem['category']> = {
      'contact': 'CLIENT_CONTACT',
      'document': 'DOCUMENT_PREP',
      'calcul': 'CALCULATION',
      'suivi': 'FOLLOW_UP',
      'compliance': 'COMPLIANCE',
      'expertise': 'EXPERTISE',
      'admin': 'ADMIN'
    };
    return mapping[category?.toLowerCase()];
  }

  private mapFrancisPriority(priority: any): ActionItem['priority'] | undefined {
    const mapping: Record<string, ActionItem['priority']> = {
      'critique': 'CRITIQUE',
      'high': 'HAUTE',
      'haute': 'HAUTE',
      'medium': 'MOYENNE',
      'moyenne': 'MOYENNE',
      'low': 'FAIBLE',
      'faible': 'FAIBLE'
    };
    return mapping[priority?.toLowerCase()];
  }

  private mapFrancisUrgency(urgency: any): ActionItem['urgency'] | undefined {
    const mapping: Record<string, ActionItem['urgency']> = {
      'immediate': 'IMMEDIATE',
      'today': 'AUJOURD_HUI',
      'week': 'CETTE_SEMAINE',
      'month': 'CE_MOIS',
      'later': 'PLUS_TARD'
    };
    return mapping[urgency?.toLowerCase()];
  }

  private mapFrancisAssignee(assignee: any): ActionItem['assignedTo'] | undefined {
    const mapping: Record<string, ActionItem['assignedTo']> = {
      'advisor': 'ADVISOR',
      'assistant': 'ASSISTANT',
      'expert': 'EXPERT',
      'client': 'CLIENT'
    };
    return mapping[assignee?.toLowerCase()];
  }

  private async saveActions(actions: ActionItem[]): Promise<void> {
    try {
      const actionsData = actions.map(action => ({
        ...action,
        createdAt: action.createdAt.toISOString(),
        dueDate: action.dueDate?.toISOString(),
        completedAt: action.completedAt?.toISOString()
      }));
      
      localStorage.setItem('francis_actions', JSON.stringify(actionsData));
      
      if (process.env.REACT_APP_SAVE_ACTIONS === 'true') {
        await fetch(`${this.francisApiUrl}/actions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(actionsData)
        });
      }
      
    } catch (error) {
      console.warn('Erreur sauvegarde actions:', error);
    }
  }

  // API publique
  async getAllActions(): Promise<ActionItem[]> {
    return Array.from(this.actions.values());
  }

  async getActionsByClient(clientId: string): Promise<ActionItem[]> {
    return Array.from(this.actions.values()).filter(action => action.clientId === clientId);
  }

  async updateActionStatus(actionId: string, status: ActionItem['status'], progress?: number): Promise<void> {
    const action = this.actions.get(actionId);
    if (action) {
      action.status = status;
      if (progress !== undefined) action.progress = progress;
      if (status === 'DONE') action.completedAt = new Date();
      
      this.actions.set(actionId, action);
      await this.saveActions([action]);
    }
  }

  async addManualAction(actionData: Partial<ActionItem>): Promise<ActionItem> {
    const action: ActionItem = {
      id: `manual-${Date.now()}`,
      title: actionData.title || 'Action manuelle',
      description: actionData.description || '',
      category: actionData.category || 'FOLLOW_UP',
      priority: actionData.priority || 'MOYENNE',
      urgency: actionData.urgency || 'CETTE_SEMAINE',
      source: 'MANUAL',
      createdAt: new Date(),
      estimatedDuration: actionData.estimatedDuration || 30,
      assignedTo: actionData.assignedTo || 'ADVISOR',
      owner: actionData.owner || 'francis',
      clientId: actionData.clientId,
      relatedDocuments: actionData.relatedDocuments || [],
      dependencies: actionData.dependencies || [],
      tags: actionData.tags || [],
      status: 'TODO',
      progress: 0,
      notes: [],
      autoGenerated: false,
      businessImpact: actionData.businessImpact || 'NONE'
    };
    
    this.actions.set(action.id, action);
    await this.saveActions([action]);
    
    return action;
  }
}

export default new ActionExtractor();
