"""
üéØ D√âTECTEUR DE PROFILS FISCAUX POUR FRANCIS
============================================

Ce module analyse les questions des utilisateurs pour d√©tecter automatiquement
leur profil fiscal et orienter Francis vers les bonnes connaissances.
"""

import re
from typing import Dict, List, Optional, Tuple
from enum import Enum
from dataclasses import dataclass
from knowledge_base_multi_profiles import ProfileType, RegimeFiscal, ThemeFiscal

@dataclass
class ProfileMatch:
    """R√©sultat de d√©tection de profil"""
    profile_type: ProfileType
    regime_fiscal: Optional[RegimeFiscal]
    theme_fiscal: Optional[ThemeFiscal]
    confidence_score: float
    detected_keywords: List[str]

class ProfileDetector:
    """D√©tecteur de profils fiscaux bas√© sur l'analyse textuelle"""
    
    def __init__(self):
        self.profile_patterns = self._build_profile_patterns()
        self.regime_patterns = self._build_regime_patterns()
        self.theme_patterns = self._build_theme_patterns()
    
    def detect_profile(self, question: str) -> List[ProfileMatch]:
        """
        D√©tecte les profils fiscaux potentiels dans une question
        
        Args:
            question: Question de l'utilisateur
            
        Returns:
            Liste des profils d√©tect√©s avec scores de confiance
        """
        question_lower = question.lower()
        matches = []
        
        # Analyser chaque type de profil
        for profile_type, patterns in self.profile_patterns.items():
            score, keywords = self._calculate_profile_score(question_lower, patterns)
            if score > 0.3:  # Seuil de confiance minimum
                # D√©tecter le r√©gime fiscal associ√©
                regime = self._detect_regime(question_lower, profile_type)
                # D√©tecter le th√®me fiscal
                theme = self._detect_theme(question_lower)
                
                matches.append(ProfileMatch(
                    profile_type=profile_type,
                    regime_fiscal=regime,
                    theme_fiscal=theme,
                    confidence_score=score,
                    detected_keywords=keywords
                ))
        
        # Trier par score de confiance d√©croissant
        matches.sort(key=lambda x: x.confidence_score, reverse=True)
        return matches
    
    def _build_profile_patterns(self) -> Dict[ProfileType, Dict[str, List[str]]]:
        """Construit les patterns de d√©tection pour chaque profil"""
        return {
            ProfileType.ENTREPRENEUR_INDIVIDUEL: {
                "primary": [
                    "entrepreneur individuel", "ei", "auto entrepreneur", "auto-entrepreneur",
                    "micro entreprise", "micro-entreprise", "travailleur ind√©pendant"
                ],
                "secondary": [
                    "urssaf", "rsi", "charges sociales", "cotisations", "bic", "bnc"
                ],
                "context": [
                    "cr√©er entreprise", "statut juridique", "r√©gime fiscal"
                ]
            },
            
            ProfileType.DIRIGEANT_SASU: {
                "primary": [
                    "sasu", "pr√©sident sasu", "dirigeant sasu", "soci√©t√© par actions simplifi√©e"
                ],
                "secondary": [
                    "dividendes", "r√©mun√©ration dirigeant", "is", "imp√¥t soci√©t√©",
                    "assimil√© salari√©", "cotisations sociales dirigeant"
                ],
                "context": [
                    "optimisation r√©mun√©ration", "arbitrage salaire dividendes"
                ]
            },
            
            ProfileType.GERANT_SARL: {
                "primary": [
                    "sarl", "g√©rant sarl", "g√©rant majoritaire", "g√©rant minoritaire",
                    "soci√©t√© √† responsabilit√© limit√©e"
                ],
                "secondary": [
                    "tns", "travailleur non salari√©", "parts sociales",
                    "g√©rant √©galitaire", "r√©mun√©ration g√©rant"
                ],
                "context": [
                    "statut g√©rant", "cotisations tns", "r√©gime social"
                ]
            },
            
            ProfileType.INVESTISSEUR_SCI: {
                "primary": [
                    "sci", "soci√©t√© civile immobili√®re", "investissement immobilier"
                ],
                "secondary": [
                    "revenus fonciers", "location", "parts sci", "plus values immobili√®res",
                    "ir sci", "is sci", "amortissement immobilier"
                ],
                "context": [
                    "d√©ficit foncier", "choix fiscal sci", "transmission patrimoine"
                ]
            },
            
            ProfileType.GROUPE_HOLDING: {
                "primary": [
                    "holding", "soci√©t√© m√®re", "filiale", "groupe soci√©t√©"
                ],
                "secondary": [
                    "int√©gration fiscale", "consolidation", "r√©gime m√®re fille",
                    "dividendes filiale", "plus values cession"
                ],
                "context": [
                    "optimisation groupe", "restructuration", "transmission entreprise"
                ]
            },
            
            ProfileType.LOUEUR_MEUBLE: {
                "primary": [
                    "lmnp", "lmp", "location meubl√©e", "loueur meubl√©",
                    "meubl√© professionnel", "meubl√© non professionnel"
                ],
                "secondary": [
                    "amortissement mobilier", "r√©gime r√©el", "d√©ficit lmnp",
                    "seuils lmp", "airbnb", "location courte dur√©e"
                ],
                "context": [
                    "investissement locatif", "optimisation meubl√©", "fiscalit√© location"
                ]
            },
            
            ProfileType.PROFESSIONNEL_LIBERAL: {
                "primary": [
                    "profession lib√©rale", "lib√©ral", "m√©decin", "avocat", "architecte",
                    "consultant", "conseil", "expert comptable", "notaire"
                ],
                "secondary": [
                    "bnc", "b√©n√©fices non commerciaux", "honoraires",
                    "charges professionnelles", "formation continue"
                ],
                "context": [
                    "d√©duction charges", "r√©gime d√©claratif", "cotisations ordinales"
                ]
            },
            
            ProfileType.COMMERCANT: {
                "primary": [
                    "commer√ßant", "commerce", "magasin", "boutique", "vente"
                ],
                "secondary": [
                    "stocks", "marchandises", "tva", "r√©gime r√©el", "bic"
                ],
                "context": [
                    "gestion stocks", "franchise tva", "comptabilit√© commerce"
                ]
            },
            
            ProfileType.ARTISAN: {
                "primary": [
                    "artisan", "artisanat", "m√©tier manuel", "chambre m√©tiers"
                ],
                "secondary": [
                    "qualification artisanale", "bic artisan", "charges mati√®res"
                ],
                "context": [
                    "statut artisan", "r√©gime fiscal artisan"
                ]
            }
        }
    
    def _build_regime_patterns(self) -> Dict[RegimeFiscal, List[str]]:
        """Patterns pour d√©tecter les r√©gimes fiscaux"""
        return {
            RegimeFiscal.MICRO_BIC: [
                "micro bic", "micro-bic", "r√©gime micro", "auto entrepreneur",
                "seuils micro", "abattement forfaitaire"
            ],
            RegimeFiscal.MICRO_BNC: [
                "micro bnc", "micro-bnc", "r√©gime micro bnc", "abattement 34"
            ],
            RegimeFiscal.REEL_SIMPLIFIE: [
                "r√©el simplifi√©", "reel simplifie", "r√©gime r√©el", "charges r√©elles"
            ],
            RegimeFiscal.REEL_NORMAL: [
                "r√©el normal", "reel normal", "comptabilit√© compl√®te"
            ],
            RegimeFiscal.IMPOT_SOCIETES: [
                "is", "imp√¥t soci√©t√©", "impot societe", "taux is", "15% 25%"
            ],
            RegimeFiscal.IMPOT_REVENU: [
                "ir", "imp√¥t revenu", "impot revenu", "bar√®me progressif", "tmi"
            ],
            RegimeFiscal.LMNP: [
                "lmnp", "loueur meubl√© non professionnel", "seuils lmnp"
            ],
            RegimeFiscal.LMP: [
                "lmp", "loueur meubl√© professionnel", "condition lmp"
            ]
        }
    
    def _build_theme_patterns(self) -> Dict[ThemeFiscal, List[str]]:
        """Patterns pour d√©tecter les th√®mes fiscaux"""
        return {
            ThemeFiscal.TVA: [
                "tva", "taxe valeur ajout√©e", "franchise tva", "r√©cup√©ration tva",
                "d√©claration ca3", "r√©gime tva"
            ],
            ThemeFiscal.URSSAF: [
                "urssaf", "cotisations sociales", "charges sociales", "rsi",
                "tns", "assimil√© salari√©"
            ],
            ThemeFiscal.DIVIDENDES: [
                "dividendes", "distribution", "pfu", "flat tax", "abattement 40%"
            ],
            ThemeFiscal.AMORTISSEMENTS: [
                "amortissement", "amortir", "d√©pr√©ciation", "immobilisation"
            ],
            ThemeFiscal.PER: [
                "per", "plan √©pargne retraite", "d√©duction retraite", "madelin"
            ],
            ThemeFiscal.PEA: [
                "pea", "plan √©pargne actions", "plus values", "exon√©ration"
            ],
            ThemeFiscal.OPTIMISATION: [
                "optimisation", "optimiser", "r√©duire imp√¥ts", "√©conomie fiscale",
                "conseil fiscal", "strat√©gie fiscale"
            ],
            ThemeFiscal.INTEGRATION_FISCALE: [
                "int√©gration fiscale", "groupe fiscal", "consolidation"
            ],
            ThemeFiscal.PLUS_VALUES: [
                "plus values", "plus-values", "cession", "vente"
            ],
            ThemeFiscal.DEFISCALISATION: [
                "d√©fiscalisation", "d√©fiscaliser", "r√©duction imp√¥t",
                "pinel", "malraux", "girardin"
            ]
        }
    
    def _calculate_profile_score(self, question: str, patterns: Dict[str, List[str]]) -> Tuple[float, List[str]]:
        """Calcule le score de correspondance pour un profil"""
        score = 0.0
        detected_keywords = []
        
        # Mots-cl√©s primaires (poids fort)
        for keyword in patterns.get("primary", []):
            if keyword in question:
                score += 1.0
                detected_keywords.append(keyword)
        
        # Mots-cl√©s secondaires (poids moyen)
        for keyword in patterns.get("secondary", []):
            if keyword in question:
                score += 0.6
                detected_keywords.append(keyword)
        
        # Mots-cl√©s contextuels (poids faible)
        for keyword in patterns.get("context", []):
            if keyword in question:
                score += 0.3
                detected_keywords.append(keyword)
        
        # Normaliser le score (0-1)
        max_possible_score = len(patterns.get("primary", [])) * 1.0 + \
                           len(patterns.get("secondary", [])) * 0.6 + \
                           len(patterns.get("context", [])) * 0.3
        
        if max_possible_score > 0:
            score = min(score / max_possible_score, 1.0)
        
        return score, detected_keywords
    
    def _detect_regime(self, question: str, profile_type: ProfileType) -> Optional[RegimeFiscal]:
        """D√©tecte le r√©gime fiscal le plus probable"""
        best_regime = None
        best_score = 0
        
        for regime, keywords in self.regime_patterns.items():
            score = sum(1 for keyword in keywords if keyword in question)
            if score > best_score:
                best_score = score
                best_regime = regime
        
        return best_regime
    
    def _detect_theme(self, question: str) -> Optional[ThemeFiscal]:
        """D√©tecte le th√®me fiscal principal"""
        best_theme = None
        best_score = 0
        
        for theme, keywords in self.theme_patterns.items():
            score = sum(1 for keyword in keywords if keyword in question)
            if score > best_score:
                best_score = score
                best_theme = theme
        
        return best_theme

# Instance globale
profile_detector = ProfileDetector()
